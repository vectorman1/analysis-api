// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package instrument_service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// InstrumentServiceClient is the client API for InstrumentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstrumentServiceClient interface {
	GetPaged(ctx context.Context, in *PagedRequest, opts ...grpc.CallOption) (*PagedResponse, error)
	Overview(ctx context.Context, in *InstrumentRequest, opts ...grpc.CallOption) (*InstrumentOverview, error)
	Get(ctx context.Context, in *InstrumentRequest, opts ...grpc.CallOption) (*Instrument, error)
	UpdateAll(ctx context.Context, in *StartUpdateJobRequest, opts ...grpc.CallOption) (*UpdateAllResponse, error)
	History(ctx context.Context, in *HistoryRequest, opts ...grpc.CallOption) (*HistoryResponse, error)
	Chart(ctx context.Context, in *ChartRequest, opts ...grpc.CallOption) (*ChartResponse, error)
	UpdateAllJob(ctx context.Context, in *StartUpdateJobRequest, opts ...grpc.CallOption) (*StartUpdateJobResponse, error)
}

type instrumentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInstrumentServiceClient(cc grpc.ClientConnInterface) InstrumentServiceClient {
	return &instrumentServiceClient{cc}
}

func (c *instrumentServiceClient) GetPaged(ctx context.Context, in *PagedRequest, opts ...grpc.CallOption) (*PagedResponse, error) {
	out := new(PagedResponse)
	err := c.cc.Invoke(ctx, "/v1.instrument_service.InstrumentService/GetPaged", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instrumentServiceClient) Overview(ctx context.Context, in *InstrumentRequest, opts ...grpc.CallOption) (*InstrumentOverview, error) {
	out := new(InstrumentOverview)
	err := c.cc.Invoke(ctx, "/v1.instrument_service.InstrumentService/Overview", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instrumentServiceClient) Get(ctx context.Context, in *InstrumentRequest, opts ...grpc.CallOption) (*Instrument, error) {
	out := new(Instrument)
	err := c.cc.Invoke(ctx, "/v1.instrument_service.InstrumentService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instrumentServiceClient) UpdateAll(ctx context.Context, in *StartUpdateJobRequest, opts ...grpc.CallOption) (*UpdateAllResponse, error) {
	out := new(UpdateAllResponse)
	err := c.cc.Invoke(ctx, "/v1.instrument_service.InstrumentService/UpdateAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instrumentServiceClient) History(ctx context.Context, in *HistoryRequest, opts ...grpc.CallOption) (*HistoryResponse, error) {
	out := new(HistoryResponse)
	err := c.cc.Invoke(ctx, "/v1.instrument_service.InstrumentService/History", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instrumentServiceClient) Chart(ctx context.Context, in *ChartRequest, opts ...grpc.CallOption) (*ChartResponse, error) {
	out := new(ChartResponse)
	err := c.cc.Invoke(ctx, "/v1.instrument_service.InstrumentService/Chart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instrumentServiceClient) UpdateAllJob(ctx context.Context, in *StartUpdateJobRequest, opts ...grpc.CallOption) (*StartUpdateJobResponse, error) {
	out := new(StartUpdateJobResponse)
	err := c.cc.Invoke(ctx, "/v1.instrument_service.InstrumentService/UpdateAllJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstrumentServiceServer is the server API for InstrumentService service.
// All implementations must embed UnimplementedInstrumentServiceServer
// for forward compatibility
type InstrumentServiceServer interface {
	GetPaged(context.Context, *PagedRequest) (*PagedResponse, error)
	Overview(context.Context, *InstrumentRequest) (*InstrumentOverview, error)
	Get(context.Context, *InstrumentRequest) (*Instrument, error)
	UpdateAll(context.Context, *StartUpdateJobRequest) (*UpdateAllResponse, error)
	History(context.Context, *HistoryRequest) (*HistoryResponse, error)
	Chart(context.Context, *ChartRequest) (*ChartResponse, error)
	UpdateAllJob(context.Context, *StartUpdateJobRequest) (*StartUpdateJobResponse, error)
	mustEmbedUnimplementedInstrumentServiceServer()
}

// UnimplementedInstrumentServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInstrumentServiceServer struct {
}

func (UnimplementedInstrumentServiceServer) GetPaged(context.Context, *PagedRequest) (*PagedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaged not implemented")
}
func (UnimplementedInstrumentServiceServer) Overview(context.Context, *InstrumentRequest) (*InstrumentOverview, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Overview not implemented")
}
func (UnimplementedInstrumentServiceServer) Get(context.Context, *InstrumentRequest) (*Instrument, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInstrumentServiceServer) UpdateAll(context.Context, *StartUpdateJobRequest) (*UpdateAllResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAll not implemented")
}
func (UnimplementedInstrumentServiceServer) History(context.Context, *HistoryRequest) (*HistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method History not implemented")
}
func (UnimplementedInstrumentServiceServer) Chart(context.Context, *ChartRequest) (*ChartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chart not implemented")
}
func (UnimplementedInstrumentServiceServer) UpdateAllJob(context.Context, *StartUpdateJobRequest) (*StartUpdateJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAllJob not implemented")
}
func (UnimplementedInstrumentServiceServer) mustEmbedUnimplementedInstrumentServiceServer() {}

// UnsafeInstrumentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstrumentServiceServer will
// result in compilation errors.
type UnsafeInstrumentServiceServer interface {
	mustEmbedUnimplementedInstrumentServiceServer()
}

func RegisterInstrumentServiceServer(s *grpc.Server, srv InstrumentServiceServer) {
	s.RegisterService(&_InstrumentService_serviceDesc, srv)
}

func _InstrumentService_GetPaged_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PagedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstrumentServiceServer).GetPaged(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.instrument_service.InstrumentService/GetPaged",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstrumentServiceServer).GetPaged(ctx, req.(*PagedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstrumentService_Overview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstrumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstrumentServiceServer).Overview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.instrument_service.InstrumentService/Overview",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstrumentServiceServer).Overview(ctx, req.(*InstrumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstrumentService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstrumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstrumentServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.instrument_service.InstrumentService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstrumentServiceServer).Get(ctx, req.(*InstrumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstrumentService_UpdateAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartUpdateJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstrumentServiceServer).UpdateAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.instrument_service.InstrumentService/UpdateAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstrumentServiceServer).UpdateAll(ctx, req.(*StartUpdateJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstrumentService_History_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstrumentServiceServer).History(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.instrument_service.InstrumentService/History",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstrumentServiceServer).History(ctx, req.(*HistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstrumentService_Chart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstrumentServiceServer).Chart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.instrument_service.InstrumentService/Chart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstrumentServiceServer).Chart(ctx, req.(*ChartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstrumentService_UpdateAllJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartUpdateJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstrumentServiceServer).UpdateAllJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.instrument_service.InstrumentService/UpdateAllJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstrumentServiceServer).UpdateAllJob(ctx, req.(*StartUpdateJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _InstrumentService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1.instrument_service.InstrumentService",
	HandlerType: (*InstrumentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPaged",
			Handler:    _InstrumentService_GetPaged_Handler,
		},
		{
			MethodName: "Overview",
			Handler:    _InstrumentService_Overview_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InstrumentService_Get_Handler,
		},
		{
			MethodName: "UpdateAll",
			Handler:    _InstrumentService_UpdateAll_Handler,
		},
		{
			MethodName: "History",
			Handler:    _InstrumentService_History_Handler,
		},
		{
			MethodName: "Chart",
			Handler:    _InstrumentService_Chart_Handler,
		},
		{
			MethodName: "UpdateAllJob",
			Handler:    _InstrumentService_UpdateAllJob_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "instrument_service.proto",
}
